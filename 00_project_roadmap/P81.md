# P81: Improvement Plan for P75.md

## What's Weak / Missing

### Event Delivery Gaps
- No specification for synchronous vs asynchronous emission
- Missing delivery guarantee definition (at-most-once, at-least-once, exactly-once)
- No buffering/batching strategy for high throughput scenarios
- No circuit breaker for event storage failures

### Schema Versioning Gaps
- No event schema version field
- Missing forward/backward compatibility strategy
- No payload validation specification

### Payload Safety Gaps
- "Sanitized stack trace" undefined - what gets removed?
- No payload size limits defined
- No PII detection/redaction specification
- Missing structured error format for error_occurred events

### Context Propagation Gaps
- Correlation ID format unspecified (UUID v4? ULID? custom?)
- No specification for context var isolation in concurrent requests
- Missing parent-child correlation for nested operations

### Performance Gaps
- No overhead budget for event emission
- Missing async write verification
- No I/O consideration for high-frequency writes

## Why This Matters

Event emission runs on every request. Without async guarantees, slow event storage blocks response delivery. Without schema versioning, consumers break when event format changes. Unsanitized payloads may leak PII or secrets into logs. Missing correlation links make distributed tracing useless for debugging.

## Proposed Improvements

### 1. Define Delivery Guarantees

Add to section 1 (Objective):
```markdown
**Delivery Guarantee**: At-most-once
- Event emission MUST NOT block request flow
- Event loss is acceptable; request completion is not
- Use fire-and-forget async pattern
```

Add success criterion:
- [ ] Event storage failure does not cause HTTP 500 response
- [ ] Request latency unaffected by event storage latency (< 1ms overhead)

### 2. Add Event Schema Versioning

Modify Task 1 (EventEmitter service):
```python
# Every event includes schema version
class ObservabilityEvent:
    schema_version: int = 1  # Increment on breaking changes
    event_type: str
    payload: dict
    ...

# Version compatibility rules:
# - Consumers MUST ignore unknown fields (forward compatible)
# - Producers MUST NOT remove required fields (backward compatible)
```

Add success criterion:
- [ ] All events include schema_version field
- [ ] Event consumer handles unknown event types gracefully (log and skip)

### 3. Define Payload Sanitization Rules

Add new task:
- [ ] Payload sanitizer (2 files, ~80 LOC)
  - Tests: tests/unit/test_payload_sanitizer.py
  - Files: services/payload_sanitizer.py, services/__init__.py
  - Rules:
    - Remove: API keys, tokens, passwords (regex patterns)
    - Truncate: Stack traces to 10 frames max
    - Redact: Email addresses, phone numbers (replace with [REDACTED])
    - Limit: Total payload size to 10KB

Add success criterion:
- [ ] No API key patterns appear in stored events (verified by test)
- [ ] Stack traces truncated to 10 frames maximum
- [ ] Payload size never exceeds 10KB

### 4. Specify Correlation ID Format

Add to Task 2 (Correlation ID middleware):
```python
# Format: UUIDv7 (time-sortable, globally unique)
# Benefits: Natural chronological ordering, no coordination needed
import uuid6
correlation_id = str(uuid6.uuid7())
```

Add for nested operations:
```python
class CorrelationContext:
    correlation_id: str  # Request-level ID
    span_id: str         # Operation-level ID
    parent_span_id: Optional[str]  # For nested operations
```

Add success criterion:
- [ ] All events within a request share same correlation_id
- [ ] Nested processor calls have linked span_id -> parent_span_id

### 5. Add Circuit Breaker

Add new task:
- [ ] Event emission circuit breaker (1 file, ~50 LOC)
  - Tests: tests/unit/test_event_circuit_breaker.py
  - Files: services/event_emitter.py
  - Behavior: After 5 consecutive storage failures, stop attempting writes for 30s
  - Fallback: Log events to stderr when circuit open

Add success criterion:
- [ ] Circuit opens after 5 consecutive failures
- [ ] Circuit half-opens after 30s to test recovery
- [ ] Events logged to stderr when circuit open (no silent loss)

### 6. Define Event Type Registry

Replace ad-hoc event type list with formal registry:
```python
# services/event_types.py
class EventType(str, Enum):
    MESSAGE_RECEIVED = "message_received"
    INTENT_CLASSIFIED = "intent_classified"
    RETRIEVAL_STARTED = "retrieval_started"  # Added: was missing
    RETRIEVAL_COMPLETE = "retrieval_complete"
    LLM_STARTED = "llm_started"
    LLM_COMPLETE = "llm_complete"
    TRANSLATION_COMPLETE = "translation_complete"  # Added: was missing
    RESPONSE_SENT = "response_sent"
    ERROR_OCCURRED = "error_occurred"

    # Future types require PR review
```

Add success criterion:
- [ ] All event emissions use EventType enum (no raw strings)
- [ ] Unknown event types rejected at emission time

### 7. Add Structured Error Format

Define error_occurred payload schema:
```python
class ErrorPayload(TypedDict):
    error_type: str           # Exception class name
    error_message: str        # First 500 chars of message
    stack_frames: list[str]   # Truncated to 10 frames
    processor: str            # Which processor failed
    input_preview: str        # First 100 chars of input (sanitized)
```

Add success criterion:
- [ ] All error_occurred events conform to ErrorPayload schema
- [ ] Error messages truncated to 500 characters

## Impact on Roadmap

- **P73** must add schema_version column to ObservabilityEvent model
- **P76** event streaming must handle schema versioning in SSE format
- **P78** dashboard must display correlation chains for debugging
- Consider P86: "Distributed Tracing Integration" - export events to Jaeger/Zipkin format
