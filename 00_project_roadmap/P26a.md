# P26a: P19 Test Improvements - Fixtures & Chaos

## 1. Objective

**What**: Enhance test infrastructure with composable fixtures, chaos testing, and realistic data generators.

**Why**: Better fixtures improve developer productivity. Chaos testing verifies resilience. Realistic data generators enable thorough testing.

**Scope**:
- Included: Enhanced composable fixtures, chaos/failure injection testing, test data generators
- Excluded: CI optimizations (P26b), flaky test detection (P26b)

**Dependencies**: P19 (Integration Tests & CI)

---

## 2. Implementation Tasks

### Task 26a.1: Enhanced Test Fixtures

- [ ] Create reusable, composable fixtures (1 file, ~80 LOC)
  - **Tests**: `tests/fixtures/test_fixtures.py`
    - `test_fixture_composition()` - fixtures can combine
    - `test_fixture_cleanup()` - proper teardown
    - `test_fixture_isolation()` - tests don't share state
    - `test_fixture_parametrization()` - data-driven tests
  - **Files**: `backend/tests/fixtures/enhanced.py`
  - **Implementation**:
    ```python
    @pytest.fixture
    def knowledge_base_scenario(pg_session, mock_openai):
        """Composable scenario fixture."""
        class Scenario:
            def with_qa_pairs(self, count: int, status: QAStatus = QAStatus.ACTIVE):
                ...
            def with_embeddings(self):
                ...
            def with_categories(self, categories: List[str]):
                ...
        return Scenario(pg_session)

    # Usage:
    def test_search_by_category(knowledge_base_scenario):
        scenario = knowledge_base_scenario \
            .with_qa_pairs(10, QAStatus.ACTIVE) \
            .with_embeddings() \
            .with_categories(["billing", "support"])
    ```

### Task 26a.2: Chaos Testing

- [ ] Add failure injection for resilience testing (2 files, ~100 LOC)
  - **Tests**: `tests/chaos/test_resilience.py`
    - `test_database_connection_failure()` - handles DB down
    - `test_redis_connection_failure()` - handles cache down
    - `test_openai_timeout()` - handles slow API
    - `test_recovery_after_failure()` - system recovers
  - **Files**: `backend/tests/chaos/failure_injector.py`, `backend/tests/chaos/test_resilience.py`
  - **Implementation**:
    ```python
    class FailureInjector:
        @contextmanager
        def database_failure(self, duration_seconds: float):
            """Simulate database unavailability."""

        @contextmanager
        def redis_failure(self):
            """Simulate Redis unavailability."""

        @contextmanager
        def api_error_rate(self, rate: float):
            """Inject random API errors at specified rate."""
    ```
  - **Markers**: `@pytest.mark.chaos`

### Task 26a.3: Test Data Generators

- [ ] Generate realistic test data at scale (1 file, ~70 LOC)
  - **Tests**: `tests/unit/test_data_generators.py`
    - `test_generates_realistic_questions()` - varied formats
    - `test_generates_realistic_answers()` - varied lengths
    - `test_scales_to_thousands()` - fast generation
    - `test_deterministic_with_seed()` - reproducible
  - **Files**: `backend/tests/generators/qa_generator.py`
  - **Implementation**:
    ```python
    class QADataGenerator:
        def __init__(self, seed: int = None):
            self.faker = Faker()
            if seed:
                self.faker.seed_instance(seed)

        def generate_question(self, category: str = None) -> str:
            """Generate realistic customer question."""

        def generate_batch(self, count: int, categories: List[str] = None) -> List[dict]:
            """Generate batch of QA pair data."""
    ```

---

## 3. Success Criteria

- [ ] Enhanced fixtures reduce test setup boilerplate
- [ ] Chaos tests verify system recovers from failures
- [ ] Test data generator produces realistic data quickly
- [ ] All fixtures properly clean up after tests
- [ ] All tests pass: `pytest tests/fixtures tests/chaos tests/unit/test_data_generators.py -v`
