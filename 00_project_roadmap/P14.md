# P14: Knowledge Base Models

## 1. Objective

**What**: Create SQLAlchemy models for QAPair (knowledge content) and Embedding (vector representation) with proper base classes and mixins.

**Why**: The knowledge base stores question-answer pairs that ground chatbot responses. Embeddings enable similarity search. Separating them allows re-embedding without touching content, tracking embedding model versions, and supporting future multi-embedding strategies.

**Scope**:
- Included: Base model, soft delete mixin, QAPair model, Embedding model, QAStatus enum, Alembic migration with HNSW index
- Excluded: Repository layer (P15), services (P15+), API (P16)

**Dependencies**: P13 (pgvector support, vector column type helper)

---

## 2. Implementation Tasks

### Task 14.1: Create Base Model

- [ ] Implement base model with common fields (1 file, ~50 LOC)
  - **Tests**: `tests/unit/test_base_model.py`
    - `test_base_model_has_id()` - UUID primary key
    - `test_base_model_has_created_at()` - auto-set on insert
    - `test_base_model_has_updated_at()` - auto-update on change
    - `test_uuid_generated_on_create()` - no manual ID needed
  - **Files**: `backend/models/base.py`
  - **Implementation**:
    ```python
    class BaseModel(DeclarativeBase):
        id: Mapped[UUID] = mapped_column(primary_key=True, default=uuid.uuid4)
        created_at: Mapped[datetime] = mapped_column(default=func.now())
        updated_at: Mapped[datetime] = mapped_column(default=func.now(), onupdate=func.now())
    ```

### Task 14.2: Create Soft Delete Mixin

- [ ] Implement soft delete mixin with query helper (1 file, ~40 LOC)
  - **Tests**: `tests/unit/test_soft_delete_mixin.py`
    - `test_soft_delete_sets_deleted_at()` - timestamp populated
    - `test_is_deleted_property()` - returns boolean
    - `test_active_query_excludes_deleted()` - filter helper works
  - **Files**: `backend/models/mixins.py`
  - **Implementation**:
    ```python
    class SoftDeleteMixin:
        deleted_at: Mapped[Optional[datetime]] = mapped_column(nullable=True)

        @property
        def is_deleted(self) -> bool:
            return self.deleted_at is not None

        @classmethod
        def active(cls):
            """Query filter for non-deleted records."""
            return cls.deleted_at.is_(None)
    ```

### Task 14.3: Create QAStatus Enum

- [ ] Create status enum (1 file, ~20 LOC)
  - **Tests**: `tests/unit/test_models_qa.py`
    - `test_qa_status_has_draft()` - QAStatus.DRAFT exists
    - `test_qa_status_has_active()` - QAStatus.ACTIVE exists
    - `test_qa_status_has_archived()` - QAStatus.ARCHIVED exists
  - **Files**: `backend/models/enums.py`
  - **Values**: `DRAFT`, `ACTIVE`, `ARCHIVED`

### Task 14.4: Create QAPair Model

- [ ] Create QAPair SQLAlchemy model (2 files, ~80 LOC)
  - **Tests**: `tests/unit/test_models_qa.py`
    - `test_qa_pair_create()` - model instantiates with required fields
    - `test_qa_pair_defaults()` - status defaults to DRAFT, timestamps set
    - `test_qa_pair_soft_delete()` - deleted_at field exists and nullable
    - `test_qa_pair_tags_json()` - tags stored as JSON array
    - `test_qa_pair_requires_question()` - question is required
    - `test_qa_pair_requires_answer()` - answer is required
    - `test_qa_pair_inherits_base()` - has id, created_at, updated_at
    - `test_qa_pair_has_soft_delete()` - has deleted_at, is_deleted, active()
  - **Files**: `backend/models/qa_pair.py`, `backend/models/__init__.py`
  - **Implementation**:
    ```python
    class QAPair(BaseModel, SoftDeleteMixin):
        __tablename__ = "qa_pair"

        question: Mapped[str] = mapped_column(Text, nullable=False, index=True)
        answer: Mapped[str] = mapped_column(Text, nullable=False)
        category: Mapped[Optional[str]] = mapped_column(String(100), index=True)
        tags: Mapped[list] = mapped_column(JSON, default=list)
        status: Mapped[QAStatus] = mapped_column(default=QAStatus.DRAFT, index=True)

        # Relationship
        embedding: Mapped[Optional["Embedding"]] = relationship(back_populates="qa_pair", cascade="all, delete-orphan")
    ```
  - **Constraints**: Validate max lengths in service layer (question: 10000, answer: 50000)

### Task 14.5: Create Embedding Model

- [ ] Create Embedding SQLAlchemy model with conditional vector type (2 files, ~70 LOC)
  - **Tests**: `tests/unit/test_models_embedding.py`
    - `test_embedding_create()` - model instantiates with vector
    - `test_embedding_links_qa_pair()` - foreign key to QAPair works
    - `test_embedding_tracks_model_version()` - model_version field exists
    - `test_embedding_vector_dimensions()` - vector is 1536 dimensions
    - `test_embedding_cascade_delete()` - deletes with QAPair
    - `test_embedding_model_uses_vector_on_postgresql()`
    - `test_embedding_model_uses_json_on_sqlite()`
  - **Files**: `backend/models/embedding.py`, `backend/models/__init__.py`
  - **Implementation**:
    ```python
    from backend.db.vector import get_vector_column_type

    class Embedding(BaseModel):
        __tablename__ = "embedding"

        qa_pair_id: Mapped[UUID] = mapped_column(ForeignKey("qa_pair.id"), unique=True, index=True)
        vector = mapped_column(get_vector_column_type(1536))  # Vector or JSON
        model_version: Mapped[str] = mapped_column(String(50))

        # Relationship
        qa_pair: Mapped["QAPair"] = relationship(back_populates="embedding")
    ```

### Task 14.6: Database Migration with HNSW Index

- [ ] Create migration for QAPair and Embedding tables (1 file, ~80 LOC)
  - **Tests**: `tests/integration/test_migrations.py`
    - `test_qa_pair_table_created()` - table exists after migration
    - `test_embedding_table_created()` - table exists after migration
    - `test_qa_pair_indexes_created()` - status, category indexes exist
    - `test_hnsw_index_created()` - vector index exists and is HNSW type
    - `test_hnsw_index_works_on_empty_table()` - no training data needed
  - **Files**: `backend/alembic/versions/xxxx_create_qa_tables.py`
  - **Indexes**:
    ```python
    # QAPair indexes
    Index('ix_qa_pair_status', QAPair.status)
    Index('ix_qa_pair_category', QAPair.category)

    # Embedding HNSW index (works without training data, unlike IVFFlat)
    Index('ix_embedding_vector', Embedding.vector,
          postgresql_using='hnsw',
          postgresql_ops={'vector': 'vector_cosine_ops'})
    ```

---

## 3. Success Criteria

- [ ] BaseModel provides id, created_at, updated_at to all models
- [ ] SoftDeleteMixin provides deleted_at, is_deleted, active() filter
- [ ] QAPair can be created, saved, and queried
- [ ] Embedding can be created with 1536-dimension vector (or JSON on SQLite)
- [ ] Foreign key constraint enforced between Embedding and QAPair
- [ ] Soft delete works via mixin (deleted_at populated, record remains)
- [ ] Migration applies cleanly on PostgreSQL with HNSW index
- [ ] HNSW index works immediately (no training data required)
- [ ] All model tests pass: `pytest tests/unit/test_models_*.py tests/unit/test_base_model.py tests/unit/test_soft_delete_mixin.py -v`
- [ ] Coverage â‰¥80% for model files

---

## 4. Technical Notes

**Why HNSW over IVFFlat**: IVFFlat requires training data to build the index. On an empty table, it fails or produces a useless index. HNSW works immediately.

**Soft Delete Pattern**: All repository queries must use `QAPair.active()` filter by default.

**UUID Generation**: Server-side via `default=uuid.uuid4` in SQLAlchemy.

**Field Length Validation**: Enforced in P15 service layer for better error messages.
