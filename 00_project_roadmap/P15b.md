# P15b: QA Service - Repository & Service

## 1. Objective

**What**: Build QA repository and service with CRUD operations, status workflow, pagination, and filtering.

**Why**: The service layer centralizes business logic, enforces workflow rules, and provides a testable interface for both API and chat pipeline.

**Scope**:
- Included: QA repository, QA service, CRUD operations, status transitions, pagination, filtering, text search
- Excluded: Foundation utilities (P15a), API endpoints (P16)

**Dependencies**: P15a (exceptions, sanitization, transactions), P14 (QAPair model, SoftDeleteMixin)

---

## 2. Implementation Tasks

### Task 15b.1: Create QA Repository

- [ ] Create data access layer with soft delete support (2 files, ~120 LOC)
  - **Tests**: `tests/unit/test_qa_repository.py`
    - `test_create_qa_pair()` - inserts and returns QAPair
    - `test_get_by_id()` - retrieves by UUID
    - `test_get_by_id_excludes_deleted()` - soft-deleted not returned
    - `test_list_all()` - returns all non-deleted pairs
    - `test_list_with_pagination()` - offset/limit work correctly
    - `test_list_filter_by_status()` - filters by status enum
    - `test_list_filter_by_category()` - filters by category string
    - `test_list_filter_by_search_term()` - ILIKE on question/answer
    - `test_update()` - updates fields, bumps updated_at
    - `test_soft_delete()` - sets deleted_at, doesn't remove row
    - `test_count()` - returns total matching count
  - **Files**: `backend/repositories/qa_repository.py`, `backend/repositories/__init__.py`
  - **Implementation**:
    ```python
    class QARepository:
        def __init__(self, session: Session):
            self._session = session

        def create(self, qa_pair: QAPair) -> QAPair
        def get_by_id(self, id: UUID) -> Optional[QAPair]  # Uses .active() filter
        def list(self, offset, limit, status, category, search) -> List[QAPair]
        def count(self, status, category, search) -> int
        def update(self, qa_pair: QAPair) -> QAPair
        def soft_delete(self, id: UUID) -> bool
    ```

### Task 15b.2: Create QA Service with CRUD

- [ ] Create QA service with dependency injection (2 files, ~150 LOC)
  - **Tests**: `tests/unit/test_qa_service.py`
    - `test_service_accepts_mock_repository()` - DI works
    - `test_create_qa_pair()` - creates with DRAFT status
    - `test_create_validates_question_not_empty()` - raises on empty
    - `test_create_validates_answer_not_empty()` - raises on empty
    - `test_create_validates_question_max_length()` - rejects > 10000 chars
    - `test_create_validates_answer_max_length()` - rejects > 50000 chars
    - `test_create_sanitizes_input()` - strips whitespace, removes HTML
    - `test_get_qa_pair()` - retrieves by ID
    - `test_get_qa_pair_not_found()` - raises QAPairNotFoundError
    - `test_update_qa_pair()` - updates allowed fields
    - `test_delete_qa_pair()` - soft deletes
  - **Files**: `backend/services/qa_service.py`, `backend/services/__init__.py`
  - **Implementation**:
    ```python
    class QAService:
        def __init__(self, session: Session, repository: Optional[QARepository] = None):
            self._session = session
            self._repository = repository or QARepository(session)

        def create(self, question: str, answer: str, ...) -> QAPair
        def get(self, id: UUID) -> QAPair
        def update(self, id: UUID, ...) -> QAPair
        def delete(self, id: UUID) -> None
    ```

### Task 15b.3: Implement Status Workflow

- [ ] Add status transition logic (1 file, ~50 LOC)
  - **Tests**: `tests/unit/test_qa_service.py`
    - `test_change_status_draft_to_active()` - allowed
    - `test_change_status_active_to_archived()` - allowed
    - `test_change_status_draft_to_archived()` - NOT allowed, raises
    - `test_change_status_archived_to_active()` - allowed (reactivate)
    - `test_change_status_same_status()` - no-op, succeeds
  - **Files**: `backend/services/qa_service.py`
  - **Implementation**:
    ```python
    ALLOWED_TRANSITIONS = {
        QAStatus.DRAFT: {QAStatus.ACTIVE},
        QAStatus.ACTIVE: {QAStatus.ARCHIVED},
        QAStatus.ARCHIVED: {QAStatus.ACTIVE},
    }

    def change_status(self, id: UUID, new_status: QAStatus) -> QAPair:
        """Change QA pair status with workflow validation."""
    ```

### Task 15b.4: Add Pagination and Filtering

- [ ] Add list with pagination and text search (1 file, ~50 LOC)
  - **Tests**: `tests/unit/test_qa_service.py`
    - `test_list_returns_paginated_result()` - items, total, page, page_size
    - `test_list_filter_by_status()` - respects status filter
    - `test_list_filter_by_category()` - respects category filter
    - `test_list_filter_by_search_term()` - finds in question/answer
    - `test_list_search_case_insensitive()` - "Return" matches "return"
  - **Files**: `backend/services/qa_service.py`
  - **Implementation**:
    ```python
    @dataclass
    class PaginatedResult(Generic[T]):
        items: List[T]
        total: int
        page: int
        page_size: int

    def list(self, page: int = 1, page_size: int = 20, ...) -> PaginatedResult[QAPair]
    ```

---

## 3. Success Criteria

- [ ] Repository CRUD operations work with soft delete
- [ ] Service uses dependency injection for testability
- [ ] Status transitions enforce workflow rules
- [ ] Invalid transitions raise descriptive errors
- [ ] Pagination returns correct page/total
- [ ] Text search finds matches case-insensitively
- [ ] All tests pass: `pytest tests/unit/test_qa_service.py tests/unit/test_qa_repository.py -v`
- [ ] Coverage â‰¥80% for service and repository
