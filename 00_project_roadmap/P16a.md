# P16a: QA API - Schemas & Handlers

## 1. Objective

**What**: Define API schemas and exception handlers for QA endpoints.

**Why**: Consistent schemas ensure API contract stability. Exception handlers map service errors to proper HTTP responses.

**Scope**:
- Included: Error response schema, QA request/response schemas, exception handlers
- Excluded: Route implementations (P16b), authentication wiring (P16b)

**Dependencies**: P15 (QA service, exceptions)

---

## 2. Implementation Tasks

### Task 16a.1: Create Error Response Schema

- [ ] Define standardized error responses (1 file, ~60 LOC)
  - **Tests**: `tests/unit/test_error_schemas.py`
    - `test_error_response_has_code()` - machine-readable code
    - `test_error_response_has_message()` - human-readable message
    - `test_validation_error_has_details()` - field-level errors
  - **Files**: `backend/schemas/errors.py`
  - **Implementation**:
    ```python
    class ErrorResponse(BaseModel):
        error: str           # e.g., "not_found", "validation_error"
        message: str         # e.g., "QA pair not found"
        details: Optional[List[ValidationErrorDetail]] = None

    class ValidationErrorDetail(BaseModel):
        field: str
        message: str
    ```

### Task 16a.2: Create QA Schemas

- [ ] Create request/response models with validation (1 file, ~100 LOC)
  - **Tests**: `tests/unit/test_schemas_qa.py`
    - `test_qa_create_schema_valid()` - accepts valid input
    - `test_qa_create_schema_rejects_empty_question()` - validation error
    - `test_qa_create_schema_rejects_empty_answer()` - validation error
    - `test_qa_response_schema_includes_all_fields()` - all fields present
    - `test_qa_response_schema_includes_has_embedding()` - computed field
    - `test_qa_list_response_schema()` - paginated structure
    - `test_qa_status_update_schema()` - accepts valid status
    - `test_page_size_max_100()` - rejects page_size > 100
    - `test_page_min_1()` - rejects page < 1
  - **Files**: `backend/schemas/qa.py`
  - **Implementation**:
    ```python
    class QACreateRequest(BaseModel):
        question: str = Field(..., min_length=1)
        answer: str = Field(..., min_length=1)
        category: Optional[str] = None
        tags: Optional[List[str]] = None

    class QAUpdateRequest(BaseModel):
        question: Optional[str] = Field(None, min_length=1)
        answer: Optional[str] = Field(None, min_length=1)
        category: Optional[str] = None
        tags: Optional[List[str]] = None

    class QAResponse(BaseModel):
        id: UUID
        question: str
        answer: str
        category: Optional[str]
        tags: List[str]
        status: QAStatus
        has_embedding: bool
        created_at: datetime
        updated_at: datetime

    class QAListResponse(BaseModel):
        items: List[QAResponse]
        total: int
        page: int
        page_size: int

    class QAListParams:
        page: int = Query(default=1, ge=1, le=10000)
        page_size: int = Query(default=20, ge=1, le=100)
        status: Optional[QAStatus] = None
        category: Optional[str] = None
        search: Optional[str] = None
    ```

### Task 16a.3: Create Exception Handlers

- [ ] Map service exceptions to HTTP responses (1 file, ~60 LOC)
  - **Tests**: `tests/integration/test_api_errors.py`
    - `test_not_found_returns_404()` - QAPairNotFoundError â†’ 404
    - `test_validation_returns_422()` - QAValidationError â†’ 422
    - `test_invalid_transition_returns_400()` - InvalidStatusTransitionError â†’ 400
    - `test_error_response_matches_schema()` - consistent format
  - **Files**: `backend/api/exception_handlers.py`
  - **Implementation**:
    ```python
    @app.exception_handler(QAPairNotFoundError)
    async def qa_not_found_handler(request: Request, exc: QAPairNotFoundError):
        return JSONResponse(
            status_code=404,
            content=ErrorResponse(error="not_found", message=str(exc)).dict()
        )

    @app.exception_handler(QAValidationError)
    async def qa_validation_handler(request: Request, exc: QAValidationError):
        return JSONResponse(
            status_code=422,
            content=ErrorResponse(
                error="validation_error",
                message=str(exc),
                details=[ValidationErrorDetail(field=exc.field, message=exc.args[0])]
            ).dict()
        )
    ```

---

## 3. Success Criteria

- [ ] Error responses have consistent structure
- [ ] QA schemas validate input (min_length, bounds)
- [ ] Query params bounded (page_size â‰¤ 100)
- [ ] Exception handlers map to correct HTTP codes
- [ ] All tests pass: `pytest tests/unit/test_error_schemas.py tests/unit/test_schemas_qa.py tests/integration/test_api_errors.py -v`
