# P60: File Parsers

## 1. Objective

**What**: Build parsers for CSV, JSON, and plain text formats to extract QA pairs from uploaded files.

**Why**: Clients have existing FAQ documents in various formats. CSV is universal (Excel, Google Sheets export), JSON is developer-friendly (API integration), text handles copy-pasted documentation. Flexible parsing enables bulk knowledge base population.

**Scope**:
- Included: CSV parser, JSON parser, text parser, parsed QA schema, encoding detection
- Excluded: Import job tracking (P59), validation (P61), batch processing (P62)

**Dependencies**: P59 (ParseError exception)

---

## 2. Implementation Tasks

### Task 60.1: Create Parsed QA Schema

- [ ] Define schema for parsed QA pairs (1 file, ~30 LOC)
  - **Tests**: `tests/unit/test_parser_schemas.py`
    - `test_parsed_qa_has_question()` - required field
    - `test_parsed_qa_has_answer()` - required field
    - `test_parsed_qa_has_optional_category()` - nullable
    - `test_parsed_qa_has_optional_tags()` - list or None
    - `test_parsed_qa_has_source_line()` - tracks origin row
  - **Files**: `backend/schemas/import_schemas.py`
  - **Implementation**:
    ```python
    @dataclass
    class ParsedQA:
        question: str
        answer: str
        source_line: int
        category: Optional[str] = None
        tags: Optional[List[str]] = None
    ```

### Task 60.2: Create CSV Parser

- [ ] Parse CSV files with flexible column detection (1 file, ~100 LOC)
  - **Tests**: `tests/unit/test_csv_parser.py`
    - `test_parses_question_answer_columns()` - standard headers
    - `test_detects_q_a_columns()` - short form headers
    - `test_detects_query_response_columns()` - alternative headers
    - `test_handles_utf8_encoding()` - unicode content
    - `test_handles_latin1_encoding()` - legacy encoding
    - `test_handles_quoted_newlines()` - multiline cells
    - `test_extracts_category_column()` - optional category
    - `test_extracts_tags_column()` - comma-separated tags
    - `test_skips_empty_rows()` - blank rows ignored
    - `test_raises_on_missing_columns()` - ParseError for bad format
    - `test_raises_on_malformed_csv()` - ParseError with line number
  - **Files**: `backend/parsers/csv_parser.py`
  - **Implementation**:
    ```python
    QUESTION_HEADERS = {"question", "q", "query", "faq", "ask"}
    ANSWER_HEADERS = {"answer", "a", "response", "reply"}

    class CSVParser:
        def parse(self, file_content: bytes) -> List[ParsedQA]:
            """Parse CSV bytes into QA pairs."""
            encoding = self._detect_encoding(file_content)
            reader = csv.DictReader(io.StringIO(file_content.decode(encoding)))
            q_col, a_col = self._detect_columns(reader.fieldnames)
            # Parse rows, track line numbers
    ```

### Task 60.3: Create JSON Parser

- [ ] Parse JSON arrays of QA objects (1 file, ~70 LOC)
  - **Tests**: `tests/unit/test_json_parser.py`
    - `test_parses_array_of_objects()` - [{question, answer}]
    - `test_handles_nested_tags()` - tags as array
    - `test_handles_string_tags()` - tags as comma string
    - `test_raises_on_invalid_json()` - ParseError for syntax
    - `test_raises_on_non_array()` - ParseError for object root
    - `test_raises_on_missing_question()` - ParseError per item
    - `test_raises_on_missing_answer()` - ParseError per item
    - `test_handles_extra_fields()` - ignores unknown keys
    - `test_tracks_array_index_as_line()` - source_line = index
  - **Files**: `backend/parsers/json_parser.py`
  - **Implementation**:
    ```python
    class JSONParser:
        def parse(self, file_content: bytes) -> List[ParsedQA]:
            """Parse JSON bytes into QA pairs."""
            try:
                data = json.loads(file_content.decode("utf-8"))
            except json.JSONDecodeError as e:
                raise ParseError(e.lineno, f"Invalid JSON: {e.msg}")
            if not isinstance(data, list):
                raise ParseError(1, "Expected JSON array of objects")
            # Validate each object, track index
    ```

### Task 60.4: Create Text Parser

- [ ] Parse plain text with Q:/A: patterns (1 file, ~90 LOC)
  - **Tests**: `tests/unit/test_text_parser.py`
    - `test_parses_qa_pattern()` - "Q: ...\nA: ..."
    - `test_parses_question_answer_pattern()` - "Question: ...\nAnswer: ..."
    - `test_parses_numbered_questions()` - "1. Q: ..."
    - `test_handles_multiline_answers()` - answer spans lines
    - `test_handles_empty_lines_between()` - separator tolerance
    - `test_handles_mixed_patterns()` - Q: and Question: in same file
    - `test_raises_on_no_patterns_found()` - ParseError if no matches
    - `test_tracks_start_line()` - source_line = first line of pair
    - `test_handles_utf8()` - unicode content
  - **Files**: `backend/parsers/text_parser.py`
  - **Implementation**:
    ```python
    Q_PATTERNS = [r"^Q:\s*", r"^Question:\s*", r"^\d+\.\s*Q:\s*"]
    A_PATTERNS = [r"^A:\s*", r"^Answer:\s*"]

    class TextParser:
        def parse(self, file_content: bytes) -> List[ParsedQA]:
            """Parse text with Q:/A: markers into QA pairs."""
            text = file_content.decode("utf-8")
            lines = text.split("\n")
            # State machine: looking_for_question → collecting_answer
    ```

### Task 60.5: Create Parser Factory

- [ ] Factory to select parser by file type (1 file, ~30 LOC)
  - **Tests**: `tests/unit/test_parser_factory.py`
    - `test_returns_csv_parser_for_csv()` - .csv extension
    - `test_returns_json_parser_for_json()` - .json extension
    - `test_returns_text_parser_for_txt()` - .txt extension
    - `test_raises_for_unknown_type()` - unsupported extension
    - `test_detects_type_from_content()` - fallback heuristic
  - **Files**: `backend/parsers/__init__.py`
  - **Implementation**:
    ```python
    def get_parser(filename: str, content: bytes = None):
        ext = Path(filename).suffix.lower()
        if ext == ".csv":
            return CSVParser()
        elif ext == ".json":
            return JSONParser()
        elif ext in {".txt", ".text"}:
            return TextParser()
        raise ValueError(f"Unsupported file type: {ext}")
    ```

---

## 3. Success Criteria

- [ ] CSV parser handles common column naming conventions
- [ ] CSV parser detects encoding (UTF-8, Latin-1)
- [ ] JSON parser validates structure with clear errors
- [ ] Text parser handles Q:/A: patterns and multiline answers
- [ ] All parsers return ParsedQA with source_line tracking
- [ ] Parse errors include row/line number for debugging
- [ ] All tests pass: `pytest tests/unit/test_*_parser.py -v`
- [ ] Coverage ≥80% for all parser modules
