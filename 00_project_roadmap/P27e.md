# P27e: Chat Pipeline - Response Formatting & Tests

## 1. Objective

**What**: Build response formatting processor and comprehensive integration tests for the full chat pipeline.

**Why**: Response formatting adapts output for different channels (web markdown, Messenger plain text). Integration tests verify the entire pipeline works together—processors chain correctly, context flows, and end-to-end message processing succeeds.

**Scope**:
- Included: Response formatting processor, pipeline integration tests, channel adapters
- Excluded: Pipeline architecture (P27a), language (P27b), moderation/intent (P27c), RAG/LLM (P27d)

**Dependencies**: P27a-P27d (all pipeline components)

---

## 2. Implementation Tasks

### Task 27e.1: Create Response Formatting Processor

- [ ] Format final response for output (1 file, ~60 LOC)
  - **Tests**: `tests/unit/test_response_formatting_processor.py`
    - `test_passes_through_plain_text()` - simple text unchanged
    - `test_applies_character_limit()` - truncates for channel
    - `test_adds_disclaimer_if_configured()` - optional footer
    - `test_sanitizes_output()` - removes unsafe content
    - `test_stores_final_response()` - context.final_response set
    - `test_handles_missing_response()` - graceful error
  - **Files**: `backend/pipeline/processors/response_formatting.py`
  - **Implementation**:
    ```python
    class ResponseFormattingProcessor(Processor):
        name = "response_formatting"
        is_optional = False

        def __init__(self, config: ResponseFormatConfig):
            self._config = config

        async def process(self, context: PipelineContext) -> PipelineContext:
            """Format the generated response for output."""
            # Apply formatting, limits, disclaimers
            # Set context.final_response
    ```

### Task 27e.2: Create Channel Adapters

- [ ] Format responses for specific channels (1 file, ~80 LOC)
  - **Tests**: `tests/unit/test_channel_adapters.py`
    - `test_web_adapter_preserves_markdown()` - markdown intact
    - `test_messenger_adapter_strips_markdown()` - plain text
    - `test_messenger_adapter_splits_long_messages()` - 2000 char limit
    - `test_api_adapter_includes_metadata()` - sources, confidence
    - `test_adapter_factory_returns_correct_type()` - by channel
  - **Files**: `backend/pipeline/adapters/channel.py`
  - **Implementation**:
    ```python
    class ChannelAdapter(ABC):
        @abstractmethod
        def format(self, context: PipelineContext) -> ChannelResponse:
            """Format response for channel."""

    class WebAdapter(ChannelAdapter):
        """Preserves markdown, includes sources."""

    class MessengerAdapter(ChannelAdapter):
        """Plain text, splits long messages."""

    class APIAdapter(ChannelAdapter):
        """Full metadata, structured response."""

    @dataclass
    class ChannelResponse:
        messages: List[str]  # May be split for Messenger
        metadata: Optional[dict]  # For API responses
    ```

### Task 27e.3: Create Pipeline Integration Tests

- [ ] Test full message flow through pipeline (1 file, ~150 LOC)
  - **Tests**: `tests/integration/test_chat_pipeline.py`
    - `test_english_question_full_flow()` - end-to-end success
    - `test_tagalog_question_translated()` - language handling
    - `test_greeting_gets_canned_response()` - intent routing
    - `test_moderated_message_rejected()` - safety working
    - `test_no_context_gets_fallback()` - graceful handling
    - `test_context_accumulates_through_pipeline()` - data flow
    - `test_processor_timings_recorded()` - observability
    - `test_pipeline_continues_on_optional_failure()` - resilience
    - `test_pipeline_stops_on_required_failure()` - safety
  - **Files**: `tests/integration/test_chat_pipeline.py`
  - **Fixtures needed**:
    ```python
    @pytest.fixture
    def mock_llm_client():
        """Mock LLM that returns predictable responses."""

    @pytest.fixture
    def mock_translation_service():
        """Mock translation service."""

    @pytest.fixture
    def seeded_qa_pairs(pg_session):
        """QA pairs with embeddings for similarity search."""
    ```

### Task 27e.4: Create Pipeline Observability

- [ ] Emit events for monitoring (1 file, ~60 LOC)
  - **Tests**: `tests/unit/test_pipeline_observability.py`
    - `test_emits_pipeline_started()` - event on start
    - `test_emits_processor_completed()` - each processor
    - `test_emits_pipeline_completed()` - event on finish
    - `test_emits_pipeline_error()` - on failures
    - `test_includes_timing_data()` - duration in events
    - `test_includes_token_usage()` - cost tracking
  - **Files**: `backend/pipeline/observability.py`
  - **Implementation**:
    ```python
    class PipelineObserver:
        def __init__(self, event_emitter: EventEmitter):
            self._emitter = event_emitter

        def on_pipeline_started(self, context: PipelineContext) -> None:
            """Emit pipeline started event."""

        def on_processor_completed(
            self, processor: Processor, context: PipelineContext, duration_ms: float
        ) -> None:
            """Emit processor completed event."""

        def on_pipeline_completed(self, context: PipelineContext) -> None:
            """Emit pipeline completed event with full metrics."""
    ```

### Task 27e.5: Create Chat Service Facade

- [ ] High-level interface for chat endpoint (1 file, ~50 LOC)
  - **Tests**: `tests/unit/test_chat_service.py`
    - `test_processes_message_through_pipeline()` - full flow
    - `test_returns_formatted_response()` - channel-adapted
    - `test_handles_pipeline_errors()` - graceful error response
    - `test_tracks_conversation()` - stores history
    - `test_returns_metadata_for_api()` - sources, timings
  - **Files**: `backend/services/chat_service.py`
  - **Implementation**:
    ```python
    class ChatService:
        def __init__(
            self,
            pipeline: PipelineOrchestrator,
            channel_adapter: ChannelAdapter,
            conversation_service: ConversationService,
        ):
            self._pipeline = pipeline
            self._channel_adapter = channel_adapter
            self._conversation_service = conversation_service

        async def process_message(
            self, message: str, device_id: str, channel: str
        ) -> ChatResponse:
            """Process user message and return formatted response."""

    @dataclass
    class ChatResponse:
        messages: List[str]
        conversation_id: UUID
        metadata: Optional[dict]
    ```

---

## 3. Success Criteria

- [ ] Response formatting applies channel-specific rules
- [ ] Web responses preserve markdown
- [ ] Messenger responses are plain text, split if needed
- [ ] API responses include metadata (sources, timings)
- [ ] Integration tests cover full pipeline flow
- [ ] Integration tests verify context accumulation
- [ ] Observability events emitted at each stage
- [ ] Chat service provides clean facade for endpoints
- [ ] All tests pass: `pytest tests/unit/test_response_formatting_processor.py tests/unit/test_channel_adapters.py tests/integration/test_chat_pipeline.py tests/unit/test_pipeline_observability.py tests/unit/test_chat_service.py -v`
- [ ] Coverage ≥80% for formatting, adapters, and chat service
- [ ] Full pipeline integration test passes end-to-end
