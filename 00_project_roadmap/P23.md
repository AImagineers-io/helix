# P23: P16 QA API Improvements

## 1. Objective

**What**: Enhance P16 API endpoints with rate limiting, request validation, response caching, and API versioning.

**Why**: P16 provides basic REST API. Production APIs need rate limiting for abuse prevention, caching for performance, and versioning for backwards compatibility.

**Scope**:
- Included: Rate limiting, response caching, API versioning, request ID tracking, enhanced error responses
- Excluded: GraphQL, WebSocket APIs, full API gateway

**Dependencies**: P16 (QA API Endpoints)

---

## 2. Implementation Tasks

### Task 23.1: Rate Limiting

- [ ] Add per-endpoint rate limits (2 files, ~60 LOC)
  - **Tests**: `tests/integration/test_api_rate_limit.py`
    - `test_rate_limit_list_endpoint()` - 100 req/min default
    - `test_rate_limit_create_endpoint()` - 20 req/min default
    - `test_rate_limit_returns_429()` - proper error response
    - `test_rate_limit_headers_present()` - X-RateLimit-* headers
    - `test_rate_limit_per_user()` - isolated per API key
  - **Files**: `backend/api/middleware/rate_limit.py`, `backend/api/routes/qa.py`
  - **Implementation**:
    ```python
    class RateLimitMiddleware:
        def __init__(self, redis: Redis, default_limit: int = 100):
            self.redis = redis
            self.default_limit = default_limit

    def rate_limit(requests_per_minute: int):
        """Decorator for endpoint-specific rate limits."""

    @router.post("/pairs", dependencies=[Depends(rate_limit(20))])
    async def create_qa_pair(...):
        ...
    ```

### Task 23.2: Response Caching

- [ ] Cache list and get responses (2 files, ~50 LOC)
  - **Tests**: `tests/integration/test_api_cache.py`
    - `test_list_response_cached()` - second request from cache
    - `test_get_response_cached()` - individual item cached
    - `test_cache_invalidated_on_create()` - list cache cleared
    - `test_cache_invalidated_on_update()` - item cache cleared
    - `test_cache_ttl_respected()` - expires after configured time
  - **Files**: `backend/api/middleware/cache.py`, `backend/api/routes/qa.py`
  - **Implementation**:
    ```python
    def cache_response(ttl_seconds: int = 60, vary_by: List[str] = None):
        """Cache GET responses in Redis."""

    @router.get("/pairs", dependencies=[Depends(cache_response(60, vary_by=["page", "status"]))])
    async def list_qa_pairs(...):
        ...
    ```

### Task 23.3: API Versioning

- [ ] Add API version support (2 files, ~40 LOC)
  - **Tests**: `tests/integration/test_api_versioning.py`
    - `test_v1_endpoint_works()` - /api/v1/qa/pairs
    - `test_version_header_accepted()` - Accept-Version header
    - `test_default_to_latest()` - no version = latest
    - `test_unsupported_version_400()` - error on unknown version
  - **Files**: `backend/api/versioning.py`, `backend/main.py`
  - **Implementation**:
    ```python
    SUPPORTED_VERSIONS = ["v1"]
    DEFAULT_VERSION = "v1"

    def get_api_version(
        accept_version: Optional[str] = Header(None, alias="Accept-Version")
    ) -> str:
        """Extract and validate API version."""

    # Mount versioned routers
    app.include_router(qa_router_v1, prefix="/api/v1")
    ```

### Task 23.4: Request ID Tracking

- [ ] Add request ID for tracing (1 file, ~30 LOC)
  - **Tests**: `tests/integration/test_api_request_id.py`
    - `test_request_id_generated()` - X-Request-ID in response
    - `test_request_id_propagated()` - client-provided ID used
    - `test_request_id_in_logs()` - appears in log context
    - `test_request_id_in_errors()` - included in error responses
  - **Files**: `backend/api/middleware/request_id.py`
  - **Implementation**:
    ```python
    class RequestIDMiddleware:
        async def __call__(self, request: Request, call_next):
            request_id = request.headers.get("X-Request-ID") or str(uuid4())
            # Add to context for logging
            response = await call_next(request)
            response.headers["X-Request-ID"] = request_id
            return response
    ```

### Task 23.5: Enhanced Error Responses

- [ ] Add more context to error responses (1 file, ~40 LOC)
  - **Tests**: `tests/integration/test_api_errors_enhanced.py`
    - `test_error_includes_request_id()` - for support tickets
    - `test_error_includes_timestamp()` - when error occurred
    - `test_error_includes_path()` - which endpoint failed
    - `test_validation_error_includes_all_fields()` - all invalid fields
    - `test_error_excludes_internal_details()` - no stack traces in prod
  - **Files**: `backend/schemas/errors.py`
  - **Implementation**:
    ```python
    class EnhancedErrorResponse(BaseModel):
        error: str
        message: str
        request_id: str
        timestamp: datetime
        path: str
        details: Optional[List[ValidationErrorDetail]] = None
        # debug_info only in development mode
        debug_info: Optional[dict] = None
    ```

---

## 3. Success Criteria

- [ ] Rate limiting prevents abuse (429 after limit exceeded)
- [ ] Rate limit headers present (X-RateLimit-Limit, X-RateLimit-Remaining)
- [ ] Response caching reduces database load
- [ ] Cache invalidation works on mutations
- [ ] API versioning supports /api/v1/ prefix
- [ ] Request IDs trace through logs and responses
- [ ] Error responses include request_id for support
- [ ] All tests pass: `pytest tests/integration/test_api_rate_limit.py tests/integration/test_api_cache.py tests/integration/test_api_versioning.py tests/integration/test_api_request_id.py tests/integration/test_api_errors_enhanced.py -v`
