# P39: Improvement Plan for P32.md

## What's Weak / Missing

- **HealthTracker not integrated with FallbackOrchestrator**: Health tracking defined but never used in routing decisions.
- **AllProvidersFailedError not defined**: Referenced in code but no definition in P29 error types.
- **Graceful fallback doesn't actually check cache**: P33's cache as "last resort" mentioned but `generate_with_graceful_fallback` just returns static message.
- **No circuit breaker pattern**: Unhealthy providers still receive requests until they fail. Should skip proactively.
- **primary_error lost if fallback also fails**: `AllProvidersFailedError` only receives fallback_error in current implementation.
- **No latency tracking in orchestrator**: HealthTracker expects latency but orchestrator doesn't measure it.
- **No observability events emitted**: Fallback triggers invisible to monitoring.
- **ContentFilterError should not trigger fallback**: Content issues won't be solved by different provider.

---

## Why This Matters

Without circuit breaker, every request waits for timeout on dead provider before fallback. Lost primary_error makes debugging impossible. No observability means silent failures. Content filter fallback wastes Anthropic quota on same blocked content.

---

## Proposed Improvements

### Task 39.1: Define AllProvidersFailedError

- [ ] Add to error types (1 file modification, ~15 LOC)
  - **Tests**: `tests/unit/test_llm_errors.py`
    - `test_all_providers_failed_includes_both_errors()`
    - `test_all_providers_failed_str_shows_chain()`
  - **Files**: `backend/llm/errors.py`
  - **Implementation**:
    ```python
    class AllProvidersFailedError(LLMError):
        """All configured providers failed."""
        def __init__(self, primary_error: LLMError, fallback_error: Optional[LLMError] = None):
            self.primary_error = primary_error
            self.fallback_error = fallback_error
            errors = [f"Primary: {primary_error}"]
            if fallback_error:
                errors.append(f"Fallback: {fallback_error}")
            super().__init__(f"All providers failed - {'; '.join(errors)}")
    ```

### Task 39.2: Integrate HealthTracker with Orchestrator

- [ ] Use health status in routing (1 file modification, ~40 LOC)
  - **Tests**: `tests/unit/test_fallback_orchestrator.py`
    - `test_skips_unhealthy_primary()`
    - `test_records_success_on_healthy_response()`
    - `test_records_failure_on_error()`
  - **Files**: `backend/llm/fallback.py`
  - **Implementation**:
    ```python
    class FallbackOrchestrator:
        def __init__(
            self,
            primary: LLMProvider,
            fallback: Optional[LLMProvider],
            config: FallbackConfig,
            health_tracker: Optional[HealthTracker] = None,
        ):
            self.primary = primary
            self.fallback = fallback
            self.config = config
            self.health = health_tracker or HealthTracker()

        async def generate(self, ...) -> LLMResponse:
            primary_error = None
            start_time = time.perf_counter()

            # Try primary if healthy
            if self.health.is_healthy("primary"):
                try:
                    response = await asyncio.wait_for(
                        self.primary.generate(...),
                        timeout=self.config.primary_timeout,
                    )
                    latency = (time.perf_counter() - start_time) * 1000
                    self.health.record_success("primary", latency)
                    return response
                except (asyncio.TimeoutError, LLMError) as e:
                    primary_error = self._map_timeout(e)
                    self.health.record_failure("primary", primary_error)
            else:
                primary_error = LLMError("Primary provider unhealthy, skipped")

            # Try fallback
            if self.fallback and self.health.is_healthy("fallback"):
                ...
    ```

### Task 39.3: Skip Fallback for Content Filter Errors

- [ ] Don't fallback on content issues (1 file modification, ~10 LOC)
  - **Tests**: `tests/unit/test_fallback_orchestrator.py`
    - `test_content_filter_error_not_retried()`
    - `test_content_filter_error_raised_immediately()`
  - **Files**: `backend/llm/fallback.py`
  - **Implementation**:
    ```python
    async def generate(self, ...) -> LLMResponse:
        try:
            response = await asyncio.wait_for(...)
            ...
        except ContentFilterError:
            # Content issues won't be solved by different provider
            raise
        except (asyncio.TimeoutError, LLMError) as e:
            primary_error = self._map_timeout(e)
            ...
    ```

### Task 39.4: Add Observability Events

- [ ] Emit events on fallback triggers (1 file modification, ~25 LOC)
  - **Tests**: `tests/unit/test_fallback_orchestrator.py`
    - `test_emits_event_on_fallback()`
    - `test_emits_event_on_total_failure()`
  - **Files**: `backend/llm/fallback.py`
  - **Implementation**:
    ```python
    from typing import Callable, Optional

    @dataclass
    class FallbackEvent:
        event_type: str  # "fallback_triggered", "all_failed", "circuit_open"
        primary_error: Optional[str]
        fallback_error: Optional[str]
        provider_used: str
        timestamp: datetime

    class FallbackOrchestrator:
        def __init__(self, ..., event_callback: Optional[Callable[[FallbackEvent], None]] = None):
            ...
            self.on_event = event_callback

        def _emit(self, event: FallbackEvent):
            if self.on_event:
                self.on_event(event)

        async def generate(self, ...) -> LLMResponse:
            ...
            except (asyncio.TimeoutError, LLMError) as e:
                primary_error = self._map_timeout(e)
                self._emit(FallbackEvent(
                    event_type="fallback_triggered",
                    primary_error=str(primary_error),
                    fallback_error=None,
                    provider_used="fallback",
                    timestamp=datetime.utcnow(),
                ))
    ```

### Task 39.5: Capture Both Errors Correctly

- [ ] Fix error capture in fallback chain (1 file modification, ~10 LOC)
  - **Tests**: `tests/unit/test_fallback_orchestrator.py`
    - `test_both_errors_captured_on_total_failure()`
  - **Files**: `backend/llm/fallback.py`
  - **Implementation**:
    ```python
    async def generate(self, ...) -> LLMResponse:
        primary_error = None
        fallback_error = None

        # Try primary
        try:
            ...
        except (asyncio.TimeoutError, LLMError) as e:
            primary_error = self._map_timeout(e)

        # Try fallback
        if self.fallback:
            try:
                ...
            except (asyncio.TimeoutError, LLMError) as e:
                fallback_error = self._map_timeout(e)

        # Both failed
        raise AllProvidersFailedError(primary_error, fallback_error)
    ```

---

## Impact on Roadmap

- **P33**: `generate_with_graceful_fallback` can now pass cache reference for true last-resort lookup.
- **Observability**: FallbackEvent can be stored in ObservabilityEvent table.
- **Monitoring**: Health status enables dashboard showing provider health.
- **P29**: Must add `AllProvidersFailedError` to errors.py.
