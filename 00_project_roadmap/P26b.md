# P26b: P19 Test Improvements - CI & Quality

## 1. Objective

**What**: Optimize CI pipeline with parallelization, flaky test detection, and coverage enforcement.

**Why**: Fast CI provides quick feedback. Flaky test detection prevents false failures. Coverage enforcement maintains quality.

**Scope**:
- Included: CI parallelization, flaky test detection and quarantine, coverage threshold enforcement
- Excluded: Fixtures (P26a), chaos testing (P26a), data generators (P26a)

**Dependencies**: P19 (Integration Tests & CI), P26a

---

## 2. Implementation Tasks

### Task 26b.1: CI Parallelization

- [ ] Optimize CI for faster feedback (2 files, ~60 LOC)
  - **Tests**: CI configuration validation (manual)
  - **Files**: `.github/workflows/test-knowledge-base.yml`, `pytest.ini`
  - **Implementation**:
    ```yaml
    jobs:
      test:
        strategy:
          matrix:
            shard: [1, 2, 3, 4]
        steps:
          - run: pytest --shard-id=${{ matrix.shard }} --num-shards=4

    - uses: actions/cache@v3
      with:
        path: .test_durations
        key: test-durations-${{ github.sha }}

    - run: pytest tests/critical -x --fail-fast
    ```
    ```ini
    [pytest]
    addopts = -n auto --dist loadfile
    markers =
        critical: Tests that must pass first
        slow: Tests > 10 seconds
        chaos: Resilience tests
    ```

### Task 26b.2: Flaky Test Detection

- [ ] Identify and quarantine flaky tests (2 files, ~50 LOC)
  - **Tests**: `tests/unit/test_flaky_detection.py`
    - `test_tracks_test_outcomes()` - records history
    - `test_identifies_flaky_pattern()` - detects inconsistent
    - `test_quarantine_mechanism()` - isolates flaky tests
    - `test_retry_on_failure()` - auto retry known flaky
  - **Files**: `backend/tests/plugins/flaky_detector.py`, `conftest.py`
  - **Implementation**:
    ```python
    class FlakyDetector:
        def __init__(self, history_file: str = ".test_history.json"):
            ...

        def record_outcome(self, test_name: str, passed: bool):
            """Record test outcome for analysis."""

        def is_flaky(self, test_name: str) -> bool:
            """Check if test has inconsistent history."""

    @pytest.hookimpl(tryfirst=True)
    def pytest_runtest_makereport(item, call):
        if call.when == "call":
            flaky_detector.record_outcome(item.nodeid, call.excinfo is None)
    ```

### Task 26b.3: Test Coverage Enforcement

- [ ] Enforce coverage thresholds per module (1 file, ~30 LOC)
  - **Tests**: CI configuration validation (manual)
  - **Files**: `.coveragerc`, `.github/workflows/test-knowledge-base.yml`
  - **Implementation**:
    ```ini
    [run]
    branch = True
    source = backend

    [report]
    fail_under = 80
    exclude_lines =
        pragma: no cover
        if TYPE_CHECKING:

    [coverage:threshold]
    backend/services = 85
    backend/repositories = 80
    backend/api = 75
    ```
    ```yaml
    - run: |
        coverage run -m pytest
        coverage report --fail-under=80
    - uses: codecov/codecov-action@v3
    ```

---

## 3. Success Criteria

- [ ] CI runs in < 10 minutes with parallelization
- [ ] Flaky tests automatically detected and quarantined
- [ ] Coverage thresholds enforced per-module
- [ ] Test history tracked for flakiness analysis
- [ ] All tests pass: `pytest tests/unit/test_flaky_detection.py -v`
